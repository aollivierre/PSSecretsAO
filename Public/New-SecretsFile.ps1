<#
.SYNOPSIS
Creates a new encrypted secrets file.

.DESCRIPTION
Creates a new encrypted secrets file at the specified path using the provided data.
It can use either Windows DPAPI (recommended, tied to user/machine) or a less secure shared key (for portability) for encryption.
It encrypts the string values in the input hashtable and saves them to the specified file.

.PARAMETER FilePath
The full path where the secrets file will be created.

.PARAMETER Data
[Mandatory] A hashtable containing the key-value pairs to encrypt and save to the file.
Values that are strings will be encrypted; other types will be stored as-is.

.PARAMETER EncryptionMethod
Specifies the encryption method to use.
- DPAPI (Default): Uses Windows DPAPI, tying encryption to the current user and machine. More secure.
- Portable: Uses AES with a shared, hardcoded key. Less secure, but allows the file to be decrypted on other machines or by other users if they have the module code.

.EXAMPLE
New-SecretsFile -FilePath C:\temp\mysecrets.psd1
# Creates the file non-interactively with encrypted ApiKey (using shared key) and plain Timeout.

.OUTPUTS
Hashtable. Returns a hashtable containing the original, unencrypted key-value pairs.
#>
function New-SecretsFile {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [string]$FilePath,

        [Parameter(Mandatory = $true)]
        [hashtable]$Data,

        [Parameter()]
        [ValidateSet('DPAPI', 'Portable')]
        [string]$EncryptionMethod = 'DPAPI' # Default to more secure DPAPI
    )

    # Determine the internal ProtectionType based on user choice
    $protectionTypeForFunc = if ($EncryptionMethod -eq 'DPAPI') { 'DPAPI' } else { 'SharedKey' }
    Write-Verbose "Using protection type: $protectionTypeForFunc"

    #Ensure the directory exists
    $directory = Split-Path -Path $FilePath -Parent
    if (-not (Test-Path -Path $directory)) {
        try {
            New-Item -Path $directory -ItemType Directory -Force -ErrorAction Stop | Out-Null
            Write-Verbose "Created directory $directory"
        }
        catch {
             Write-Error "Failed to create directory '$directory'. Error: $($_.Exception.Message)"
             return $null # Indicate failure
        }
    }

    $returnData = $null
    $encryptionMethodUsed = $EncryptionMethod # Use the parameter value for metadata

    # Process the mandatory -Data parameter
    Write-Verbose "Processing -Data parameter for file creation using '$($EncryptionMethod)' method."
    $encryptedData = @{}
    foreach ($key in $Data.Keys) {
        $value = $Data[$key]
        # Only encrypt strings, store others as-is (simplistic approach)
        if ($value -is [string]) {
             try {
                 # Pass the determined protection type to Protect-String
                 $encryptedData[$key] = Protect-String -String $value -ProtectionType $protectionTypeForFunc
             }
             catch {
                  Write-Error "Failed to protect string for key '$key' using method '$($EncryptionMethod)'. Error: $($_.Exception.Message)"
                  return $null # Indicate failure
             }
        }
        else {
             $encryptedData[$key] = $value
             Write-Warning "Value for key '$key' is not a string and was not encrypted."
        }
    }
    $objectToSave = $encryptedData
    $returnData = $Data # Return the original data

    # Save the object to file
    if ($null -ne $objectToSave) {
         # Add metadata key for encryption method
         $metadataKey = '_PSSecretsAO_EncryptionMethod' # Choose a unique prefix
         $objectToSave[$metadataKey] = $encryptionMethodUsed
         
         try {
             # Build PSD1 content line by line
             $psd1Lines = @(
                 "# PowerShell Data File for Encrypted Secrets",
                 "# Generated by PSSecretsAO on $(Get-Date)",
                 "@{"
             )
             foreach ($key in $objectToSave.Keys) {
                 $value = $objectToSave[$key]
                 # Escape single quotes within the value if necessary
                 $escapedValue = $value -replace "'","''"
                 # Quote the value - assumes string or simple type representable as string
                 # Add line to the array, ensuring proper quoting and indentation
                 $psd1Lines += "    '$key' = '$escapedValue'"
             }
             $psd1Lines += "}"

             # Join lines with OS-appropriate newline and save
             $fileContent = $psd1Lines -join [System.Environment]::NewLine
             Set-Content -Path $FilePath -Value $fileContent -Encoding UTF8 -Force -ErrorAction Stop
             
             Write-Host "Secrets file saved successfully to '$FilePath'! (Encryption: $($encryptionMethodUsed))" -ForegroundColor Green
             # Return the original/plain data
             return $returnData
         }
         catch {
             Write-Error "Failed to save secrets file '$FilePath': $($_.Exception.Message)"
             return $null # Indicate failure
         }
    }
    else {
         Write-Error "No data was prepared to be saved to the secrets file."
         return $null
    }
}
